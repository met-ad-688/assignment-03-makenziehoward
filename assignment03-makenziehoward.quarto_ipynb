{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Assignment 03\n",
        "author:\n",
        "  - name: Makenzie Howard\n",
        "    affiliations:\n",
        "      - id: bu\n",
        "        name: Boston University\n",
        "        city: Boston\n",
        "        state: MA\n",
        "number-sections: true\n",
        "date: '2025-09-22'\n",
        "format:\n",
        "  html:\n",
        "    theme: cerulean\n",
        "    toc: true\n",
        "    toc-depth: 2\n",
        "    code-overflow: wrap\n",
        "  docx: \n",
        "    code-overflow: wrap\n",
        "  pdf:\n",
        "    code-overflow: wrap\n",
        "date-modified: today\n",
        "date-format: long\n",
        "--- \n",
        "\n",
        "# Load the Dataset"
      ],
      "id": "8950deab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "#| echo: true\n",
        "#| fig-align: center\n",
        "\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "import plotly.io as pio\n",
        "from pyspark.sql import SparkSession\n",
        "import re\n",
        "import numpy as np\n",
        "import plotly.graph_objects as go\n",
        "from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when\n",
        "from pyspark.sql import functions as F\n",
        "from pyspark.sql.functions import col, monotonically_increasing_id\n",
        "\n",
        "np.random.seed(42)\n",
        "\n",
        "pio.renderers.default = \"notebook\"\n",
        "\n",
        "# Initialize Spark Session\n",
        "spark = SparkSession.builder.appName(\"LightcastData\").getOrCreate()\n",
        "\n",
        "# Load Data\n",
        "df = spark.read.option(\"header\", \"true\").option(\"inferSchema\", \"true\").option(\"multiLine\",\"true\").option(\"escape\", \"\\\"\").csv(\"lightcast_job_postings.csv\")\n",
        "df.createOrReplaceTempView(\"job_postings\")\n",
        "\n",
        "# Show Schema and Sample Data\n",
        "print(\"---This is Diagnostic check, No need to print it in the final doc---\")\n",
        "\n",
        "df.printSchema() # comment this line when rendering the submission\n",
        "df.show(5)"
      ],
      "id": "07fa97c7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Data Preparation"
      ],
      "id": "54a207d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Step 1: Casting salary and experience columns\n",
        "df = (\n",
        "    df\n",
        "    .withColumn(\"SALARY\", col(\"SALARY\").cast(\"float\"))\n",
        "    .withColumn(\"SALARY_FROM\", col(\"SALARY_FROM\").cast(\"float\"))\n",
        "    .withColumn(\"SALARY_TO\", col(\"SALARY_TO\").cast(\"float\"))\n",
        "    .withColumn(\"MIN_YEARS_EXPERIENCE\", col(\"MIN_YEARS_EXPERIENCE\").cast(\"float\"))\n",
        "    .withColumn(\"MAX_YEARS_EXPERIENCE\", col(\"MAX_YEARS_EXPERIENCE\").cast(\"float\"))\n",
        ")\n",
        "\n",
        "# Step 2: Computing medians for salary columns\n",
        "def compute_median(sdf, col_name):\n",
        "    q= sdf.approxQuantile(col_name, [0.5], 0.01)\n",
        "    return q[0] if q else None\n",
        "\n",
        "median_from = compute_median(df, \"SALARY_FROM\")\n",
        "median_to = compute_median(df, \"SALARY_TO\")\n",
        "median_salary = compute_median(df, \"SALARY\")\n",
        "\n",
        "print(\"Medians:\", median_from, median_to, median_salary)\n",
        "\n",
        "# Step 3: Imputing missing salaries, but not experience\n",
        "df = df.fillna({\n",
        "    \"SALARY_FROM\" : median_from,\n",
        "    \"SALARY_TO\" : median_to,\n",
        "    \"SALARY\" : median_salary\n",
        "})\n",
        "df_filtered = df.filter(\n",
        "    (F.col(\"SALARY\") > 0) &\n",
        "    F.col(\"EMPLOYMENT_TYPE_NAME\").isNotNull() &\n",
        "    (F.trim(F.col(\"EMPLOYMENT_TYPE_NAME\")) != F.lit(\"\")) &\n",
        "    (F.lower(F.trim(F.col(\"EMPLOYMENT_TYPE_NAME\"))) != F.lit(\"none\"))\n",
        ")\n",
        "\n",
        "pdf = (\n",
        "    df_filtered\n",
        "      .select(\"EMPLOYMENT_TYPE_NAME\", \"SALARY\")\n",
        "      .toPandas()\n",
        ")\n",
        "\n",
        "\n",
        "\n",
        "# Step 5: Computing average salary\n",
        "df = df.withColumn(\"Average_Salary\", (col(\"SALARY_FROM\") + col(\"SALARY_TO\")) / 2)\n",
        "\n",
        "# Step 6: Selecting Required Columns\n",
        "export_cols = [\n",
        "  \"EDUCATION_LEVELS_NAME\",\n",
        "  \"REMOTE_TYPE_NAME\",\n",
        "  \"MAX_YEARS_EXPERIENCE\",\n",
        "  \"Average_Salary\",\n",
        "  \"median_salary\"\n",
        "  \"LOT_V6_SPECIALIZED_OCCUPATION_NAME\",\n",
        "]\n",
        "\n",
        "df_selected = df.select(*[c for c in export_cols if c in df.columns])\n",
        "\n",
        "# Step 7: Saving to CSV\n",
        "pdf = df_selected.toPandas()   # OK for small/medium data\n",
        "pdf.to_csv(\"./data/lightcast_cleaned.csv\", index=False)\n",
        "\n",
        "print(\"Data Cleaning Complete. Rows retained:\", len(pdf))"
      ],
      "id": "f850026e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Salary Distribution by Industry and Employment Type"
      ],
      "id": "92339fe2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Salary Distribution by Industry and Employment Type\n",
        "\n",
        "import os, re\n",
        "import pandas as pd\n",
        "import plotly.express as px\n",
        "from IPython.display import display\n",
        "\n",
        "# Ensure output folder exists\n",
        "os.makedirs(\"output\", exist_ok=True)\n",
        "\n",
        "# 1) Filter out missing or zero salary values and bring to pandas\n",
        "pdf = (\n",
        "    df.filter(df[\"SALARY\"] > 0)    # PySpark filter (assumes SALARY is numeric)\n",
        "      .select(\"EMPLOYMENT_TYPE_NAME\", \"SALARY\")\n",
        "      .toPandas()\n",
        ")\n",
        "\n",
        "# Optional one-time preview (set True to debug)\n",
        "SHOW_PREVIEW = False\n",
        "if SHOW_PREVIEW:\n",
        "    display(pdf.head(10))\n",
        "\n",
        "# 2) Clean employment type names (overwrite the SAME column; no new column)\n",
        "pdf[\"EMPLOYMENT_TYPE_NAME\"] = (\n",
        "    pdf[\"EMPLOYMENT_TYPE_NAME\"]\n",
        "      .astype(str)\n",
        "      .apply(lambda x: re.sub(r\"[^\\x00-\\x7F]+\", \"\", x))\n",
        ")\n",
        "\n",
        "# Make sure salary is numeric (just in case)\n",
        "pdf[\"SALARY\"] = pd.to_numeric(pdf[\"SALARY\"], errors=\"coerce\")\n",
        "\n",
        "# If a stray pluralized column exists from earlier runs, drop it\n",
        "if \"EMPLOYMENT_TYPE_NAMES\" in pdf.columns:\n",
        "    pdf = pdf.drop(columns=[\"EMPLOYMENT_TYPE_NAMES\"])\n",
        "\n",
        "# 3) Compute median salary for sorting\n",
        "median_salaries = pdf.groupby(\"EMPLOYMENT_TYPE_NAME\", dropna=False)[\"SALARY\"].median()\n",
        "\n",
        "# 4) Sort employment types based on median salary (descending)\n",
        "sorted_employment_types = median_salaries.sort_values(ascending=False).index\n",
        "\n",
        "# 5) Apply sorted categories\n",
        "pdf[\"EMPLOYMENT_TYPE_NAME\"] = pd.Categorical(\n",
        "    pdf[\"EMPLOYMENT_TYPE_NAME\"],\n",
        "    categories=sorted_employment_types,\n",
        "    ordered=True\n",
        ")\n",
        "\n",
        "# 6) Create box plot (single neutral color)\n",
        "fig = px.box(\n",
        "    pdf,\n",
        "    x=\"EMPLOYMENT_TYPE_NAME\",\n",
        "    y=\"SALARY\",\n",
        "    title=\"Salary Distribution by Employment Type\",\n",
        "    points=\"all\",\n",
        "    boxmode=\"group\",\n",
        "    \n",
        ")\n",
        "# Force black for markers and box lines\n",
        "fig.update_traces(marker_color=\"red\", line_color=\"black\")\n",
        "\n",
        "# 7) Improve layout, font styles, and axis labels\n",
        "fig.update_layout(\n",
        "    title=dict(text=\"Salary Distribution by Employment Type\",\n",
        "               font=dict(size=30, family=\"Helvetica\", color=\"black\")),\n",
        "    xaxis=dict(\n",
        "        showline=True, linewidth=2, linecolor=\"black\", mirror=True, showgrid=False,\n",
        "        categoryorder=\"array\", categoryarray=list(sorted_employment_types)\n",
        "    ),\n",
        "    yaxis=dict(\n",
        "        title=dict(text=\"Salary (K $)\", font=dict(size=24, family=\"Helvetica\", color=\"black\")),\n",
        "        tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000],\n",
        "        ticktext=[\"0\",\"50K\",\"100K\",\"150K\",\"200K\",\"250K\",\"300K\",\"350K\",\"400K\",\"450K\",\"500K\"],\n",
        "        tickfont=dict(size=18, family=\"Helvetica\", color=\"black\"),\n",
        "        showline=True, linewidth=2, linecolor=\"black\", mirror=True,\n",
        "        showgrid=True, gridcolor=\"lightgray\", gridwidth=0.5\n",
        "    ),\n",
        "    font=dict(family=\"Helvetica\", size=16, color=\"black\"),\n",
        "    boxgap=0.7, boxmode=\"group\",\n",
        "    plot_bgcolor=\"white\", paper_bgcolor=\"white\",\n",
        "    showlegend=False, height=500, width=850,\n",
        ")\n",
        "\n",
        "# In Quarto, returning fig renders it once (no need for fig.show())\n",
        "fig.show()\n",
        "\n",
        "\n",
        "# Save SVG (fallback to HTML if kaleido isn't installed)\n",
        "try:\n",
        "    # pip install kaleido\n",
        "    fig.write_image(\"output/Q1.svg\", width=850, height=500, scale=1)\n",
        "except Exception:\n",
        "    fig.write_html(\"output/Q1.html\", include_plotlyjs=\"cdn\")"
      ],
      "id": "dcede65c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "***Explanation*** This table represents salary distributions by employment type: full time, part-time, or a hybrid of both. According to the table, full-time employees make the highest salaries with part-time employees making the least. Due to its hybrid nature, full-time/part-time employees experience the broadest range of salaries."
      ],
      "id": "c2df1341"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "#| echo: false\n",
        "#| fig-align: center\n",
        "pdf = df.select(\"NAICS2_NAME\", \"SALARY\").toPandas()\n",
        "fig = px.box(pdf, x=\"NAICS2_NAME\", y=\"SALARY\", title=\"Salary Distribution by Industry\", color_discrete_sequence=[\"red\"])\n",
        "fig.update_layout(font_family=\"Helvetica\", title_font_size=16)\n",
        "fig.update_xaxes(tickangle=45, tickfont=dict(size=12))\n",
        "fig.show()"
      ],
      "id": "2e5ec39e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "***Explanation*** This table represents salary distribution by industry. According to the table, Healthcare Services, Waste Management Services, and Information Services have the largest ranges of salaries while also claiming the highest salaries. "
      ],
      "id": "1c5e2292"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#bubble graph for salary analysis by ONET Occupation Type\n",
        "#| eval:false\n",
        "#| echo:false\n",
        "\n",
        "#Step 1: spark SQL - Median Salary and job count per TITLE_NAME\n",
        "salary_analysis = spark.sql(\"\"\"\n",
        "  SELECT\n",
        "    LOT_OCCUPATION_NAME AS Occupation_name,\n",
        "    PERCENTILE(SALARY, 0.5) AS Median_Salary,\n",
        "    COUNT(*) AS Job_Postings\n",
        "  FROM job_postings\n",
        "  GROUP BY LOT_OCCUPATION_NAME\n",
        "  ORDER BY Job_Postings DESC\n",
        "  LIMIT 10\n",
        "\"\"\")\n",
        "\n",
        "#step 2: convert to pandas dataframe\n",
        "salary_pd = salary_analysis.toPandas()\n",
        "salary_pd.head()\n",
        "\n",
        "#Step 3: Bubble chart using plotly\n",
        "import plotly.express as px\n",
        "\n",
        "fig = px.scatter(\n",
        "    salary_pd,\n",
        "    x=\"Occupation_name\",\n",
        "    y=\"Median_Salary\",\n",
        "    size=\"Job_Postings\",\n",
        "    title=\"Salary Analysis by Lot Occupation Type (Bubble Chart)\",\n",
        "    labels={\n",
        "          \"LOT_OCCUPATION_NAME\": \"Lot Occupation\",\n",
        "          \"Median_Salary\": \"Median Salary\",\n",
        "          \"Job_Postings\": \"Number of Job Postings\",\n",
        "    },\n",
        "    hover_name=\"Occupation_name\",\n",
        "    size_max=60,\n",
        "    width=1000,\n",
        "    height=600,\n",
        "    color=\"Job_Postings\",\n",
        "    color_continuous_scale=\"Plasma\"\n",
        ")\n",
        "\n",
        "#Step 4: Layout customization\n",
        "fig.update_layout(\n",
        "    font_family=\"Helvetica\",\n",
        "    font_size=14,\n",
        "    title_font_size=25,\n",
        "    xaxis_title=\"Lot Occupation\",\n",
        "    yaxis_title=\"Median Salary\",\n",
        "    plot_bgcolor=\"white\",\n",
        "    xaxis=dict(\n",
        "        tickangle=-45,\n",
        "        showline=True,\n",
        "        linecolor=\"red\"\n",
        "    ),\n",
        "    yaxis=dict(\n",
        "        showline=True,\n",
        "        linecolor=\"red\"\n",
        "    )\n",
        ")\n",
        "\n",
        "# show in the doc (HTML render will display it inline)\n",
        "fig.show()\n",
        "\n",
        "# save artifact without kaleido\n",
        "import os\n",
        "os.makedirs(\"output\", exist_ok=True)\n",
        "\n",
        "try:\n",
        "    fig.write_image(\"output/Q7.svg\", width=1000, height=600, scale=1)\n",
        "except Exception:\n",
        "    # no kaleido? save interactive HTML instead\n",
        "    fig.write_html(\"output/Q7.html\", include_plotlyjs=\"cdn\")\n",
        "    print(\"Saved interactive HTML fallback to output/Q7.html (no kaleido).\")"
      ],
      "id": "5eae29f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Explanation** This bubble chart shows the top ten job titles by number of job postings. We can see that Business Intelligence Analysts and Data Mining Analysts, although the most abundent, do not have the highest salaries in comparison to more technical groups such as Computer System Engineers. The least amount of job postings lie in the business analyst and market research analyst positions, while also paying the lowest salaries.\n",
        "\n",
        "# Salary by Education Level"
      ],
      "id": "a2f3a61e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#defining education level groupings\n",
        "lower_deg = [\"Bachelor's\", \"Associate\", \"GED\", \"No Education Listed\", \"High School\"]\n",
        "higher_deg = [\"Master's degree\", \"PHD or professional degree\"]\n",
        "\n",
        "#adding EDU_GROUP column\n",
        "df = df.withColumn(\n",
        "      \"EDU_GROUP\",\n",
        "      when(col(\"EDUCATION_LEVELS_NAME\").rlike(\"|\".join([f\"(?i){deg}\" for deg in lower_deg])), \"Bachelor's or lower\")\n",
        "      when(col(\"EDUCATION_LEVELS_NAME\".rlike(\"|\".join([f\"(?i){deg}\" for deg in higher_deg])), \"Master's or PhD\")\n",
        "      .otherwise(\"Other\")\n",
        "      )\n",
        "#casting necessary columns to float\n",
        "df = df.withColumn(\"MAX_YEARS_EXPERIENCE\", col(\"MAX_YEARS_EXPERIENCE\").cast(\"float\"))\n",
        "df = df.withColumn(\"Average_Salary\", col(\"Average_Salary\").cast(\"float\"))\n",
        "\n",
        "#filtering for non-null and positive values\n",
        "df = df.filter(\n",
        "    col(\"MAX_YEARS_EXPERIENCE\").isNotNull() &\n",
        "    col(\"Average_Salary\").isNotNull() &\n",
        "    (col(\"MAX_YEARS_EXPERIENCE\") > 0) &\n",
        "    (col(\"Average_Salary\") > 0)\n",
        ")\n",
        "\n",
        "#filtering for just the two education groups\n",
        "df_filtered = df.filter(col(\"EDU_GROUP\").isin(\"Bachelor's or lower\", \"Master's or PhD\"))\n",
        "\n",
        "#converting to pandas for plotting\n",
        "df_pd = df_filtered.toPandas()\n",
        "\n",
        "fig1 = px.scatter(\n",
        "    df_pd,\n",
        "    x = \"MAX_YEARS_EXPERIENCE\",\n",
        "    y=\"Average_salary\",\n",
        "    color=\"EDU_GROUP\",\n",
        "    hover_data=[\"LOT_V6_SPECIALIZED_OCCUPATION_NAME\"],\n",
        "    title=\"<b>Experience vs Salary by Education Level<b>\",\n",
        "    opacity=0.7,\n",
        "    color_discrete_sequence=[\"blue\", \"red\"]\n",
        ")\n",
        "fig1.update_traces(marker=dict(size=7,line=dict(width=1, color=\"black\")))\n",
        "\n",
        "fig1.update_layout(\n",
        "      plot_bgcolor=\"#f9f9f9\",\n",
        "      paper_bgcolor=\"#FFF5DC\",\n",
        "      font=dict(family=\"Helvetica\", size=14),\n",
        "      title_font=dict(size=22),\n",
        "      xaxis_title=\"Years of Experience\",\n",
        "      yaxis_title=\"Average Salary USD\"\n",
        "      legend_title=\"Education Group\"\n",
        "      hoverlabel=dict(bgcolor=\"white\", font_size=13, font_family= \"Helvetica\"),\n",
        "      margin=dict(t=70, b=60, l=60, r=60),\n",
        "      xaxis=dict(\n",
        "        gridcolor=\"lightgrey\",\n",
        "        tickmode='linear',\n",
        "        dtick=1\n",
        "      ),\n",
        "      yaxis=dict(gridcolor=\"lightgrey\")\n",
        ")\n",
        "\n",
        "fig1.show()\n",
        "fig1.write_html(\"output/q_1a_Experience_vs_Salary_by_Education_Level.html\")"
      ],
      "id": "37b3f1a9",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "ec2-m03",
      "language": "python",
      "display_name": "Python (ec2-m03)",
      "path": "/home/ubuntu/.local/share/jupyter/kernels/ec2-m03"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}